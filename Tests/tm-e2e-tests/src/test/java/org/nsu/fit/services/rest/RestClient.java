package org.nsu.fit.services.rest;

import io.codearte.jfairy.Fairy;
import io.codearte.jfairy.producer.person.Person;
import org.glassfish.jersey.client.ClientConfig;
import org.nsu.fit.services.log.Logger;
import org.nsu.fit.services.rest.data.*;
import org.nsu.fit.shared.JsonMapper;

import javax.ws.rs.client.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.util.List;

public class RestClient {
    private static final String REST_URI = "http://localhost:8080/tm-backend/rest";

    private static Client client = ClientBuilder.newClient(new ClientConfig().register(RestClientLogFilter.class));

    public AccountTokenPojo authenticate(String login, String password) {
        CredentialsPojo credentialsPojo = new CredentialsPojo();

        credentialsPojo.login = login;
        credentialsPojo.password = password;

        return post("authenticate", JsonMapper.toJson(credentialsPojo, true), AccountTokenPojo.class, null);
    }

    public CustomerPojo createAutoGeneratedCustomer(AccountTokenPojo accountToken) {
        ContactPojo contactPojo = new ContactPojo();

        // Лабораторная 3: Добавить обработку генерацию фейковых имен, фамилий и логинов.
        // * Исследовать этот вопрос более детально, возможно прикрутить специальную библиотеку для генерации фейковых данных.
        Fairy fairy = Fairy.create();
        Person person = fairy.person();

        contactPojo.firstName = person.getFirstName();
        contactPojo.lastName = person.getLastName();
        contactPojo.login = person.getEmail();
        contactPojo.password = person.getPassword();

        return post("customers", JsonMapper.toJson(contactPojo, true), CustomerPojo.class, accountToken);
    }

    public ContactPojo getMyPersonalInfo(AccountTokenPojo accountToken) {
        return get("me", CustomerPojo.class, accountToken);
    }

    public ContactPojo createCustomer(CustomerPojo customerPojo, AccountTokenPojo accountToken) {
        return post("customers", JsonMapper.toJson(customerPojo, true), CustomerPojo.class, accountToken);
    }

    public TopUpBalancePojo topUpBalanceCustomer(CustomerPojo customerPojo, int money, AccountTokenPojo accountToken) {
        TopUpBalancePojo topUpBalancePojo = new TopUpBalancePojo();

        topUpBalancePojo.customerId = customerPojo.id;
        topUpBalancePojo.money = money;

        return post("/customers/top_up_balance", JsonMapper.toJson(topUpBalancePojo, true), TopUpBalancePojo.class, accountToken);
    }

    public Boolean deleteCustomer(CustomerPojo customerPojo, AccountTokenPojo accountToken) {
        return delete("customers/"+ customerPojo.id, accountToken);
    }

    public PlanPojo createPlan(PlanPojo planPojo, AccountTokenPojo accountTokenPojo){
       return post("plans", JsonMapper.toJson(planPojo, true), PlanPojo.class, accountTokenPojo);
    }

    public Boolean deletePlan(PlanPojo planPojo, AccountTokenPojo accountTokenPojo){
        return delete("plans/"+planPojo.id, accountTokenPojo);
    }

    public SubscriptionPojo createSubscription(SubscriptionPojo subscriptionPojo, AccountTokenPojo accountTokenPojo){
        return post("subscriptions", JsonMapper.toJson(subscriptionPojo, true), SubscriptionPojo.class, accountTokenPojo);
    }

    public Boolean deleteSubscription(SubscriptionPojo subscriptionPojo, AccountTokenPojo accountTokenPojo){
        return delete("plans/"+subscriptionPojo.id, accountTokenPojo);
    }

    private static Boolean delete(String path, AccountTokenPojo accountToken) {
        Invocation.Builder request = client
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        Response response = request.delete();

        int status = response.getStatus();

        if (status != 200) {
            Logger.debug("post: " + status + response.getStatusInfo().getReasonPhrase());
            return false;
        }

        Logger.debug("post: " + status);
        return true;
    }

    private static <R> R get(String path, Class<R> responseType, AccountTokenPojo accountToken) {
        Invocation.Builder request = client
                .target(REST_URI)
                .path(path)
                .request()
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        Response response = request.get();

        int status = response.getStatus();

        if (status != 200) {
            Logger.debug("post: " + status + response.getStatusInfo().getReasonPhrase());
            return null;
        }

        Logger.debug("post: " + status);

        return JsonMapper.fromJson(response.readEntity(String.class), responseType);
    }

    private static <R> R post(String path, String body, Class<R> responseType, AccountTokenPojo accountToken) {
        // Лабораторная 3: Добавить обработку Responses и Errors. Выводите их в лог.
        // Подумайте почему в filter нет Response чтобы можно было удобно его сохранить.
        Invocation.Builder request = client
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        Response response = request.post(Entity.entity(body, MediaType.APPLICATION_JSON), Response.class);

        int status = response.getStatus();

        if (status != 200) {
            Logger.debug("post: " + response.getStatus() + response.getStatusInfo().getReasonPhrase());
            return null;
        }

        Logger.debug("post: " + response.getStatus());

        if(!response.hasEntity()){
            return null;
        }

        return JsonMapper.fromJson(response.readEntity(String.class), responseType);
    }

    private static class RestClientLogFilter implements ClientRequestFilter {
        @Override
        public void filter(ClientRequestContext requestContext) {
            if (requestContext.hasEntity()) {
                Logger.debug(requestContext.getEntity().toString());
            }
            Logger.debug(requestContext.getHeaders().toString());
            Logger.debug(requestContext.getMethod());

            // Лабораторная 3: разобраться как работает данный фильтр
            // и добавить логирование METHOD и HEADERS.
        }
    }
}
